/* Generated by Yosys 0.8+299 (git sha1 ccfa2fe0, clang 6.0.0-1ubuntu2 -fPIC -Os) */

(* \nmigen.hierarchy  = "loopback" *)
(* top =  1  *)
(* generator = "nMigen" *)
module loopback(rx, clk, rst, tx);
  wire \$1 ;
  wire \$3 ;
  wire \$5 ;
  (* src = "uart.py:312" *)
  reg [7:0] \$next\data ;
  (* src = "uart.py:311" *)
  reg \$next\empty ;
  (* src = "uart.py:313" *)
  reg \$next\rx_strobe ;
  (* src = "uart.py:314" *)
  reg \$next\tx_strobe ;
  (* src = "uart.py:21" *)
  reg \$next\uart_rx_ack ;
  (* src = "uart.py:74" *)
  reg [7:0] \$next\uart_tx_data ;
  (* src = "uart.py:75" *)
  reg \$next\uart_tx_ready ;
  (* src = "/usr/local/lib/python3.6/dist-packages/nmigen-0.1-py3.6.egg/nmigen/hdl/ir.py:330" *)
  input clk;
  (* init = 8'h00 *)
  (* src = "uart.py:312" *)
  reg [7:0] data = 8'h00;
  (* init = 1'h1 *)
  (* src = "uart.py:311" *)
  reg empty = 1'h1;
  (* src = "/usr/local/lib/python3.6/dist-packages/nmigen-0.1-py3.6.egg/nmigen/hdl/ir.py:330" *)
  input rst;
  (* src = "uart.py:369" *)
  input rx;
  (* src = "uart.py:313" *)
  wire rx_strobe;
  (* src = "uart.py:368" *)
  output tx;
  (* src = "uart.py:314" *)
  wire tx_strobe;
  (* src = "uart.py:21" *)
  wire uart_rx_ack;
  (* src = "uart.py:19" *)
  wire [7:0] uart_rx_data;
  (* src = "uart.py:20" *)
  wire uart_rx_ready;
  (* src = "uart.py:76" *)
  wire uart_tx_ack;
  (* src = "uart.py:74" *)
  wire [7:0] uart_tx_data;
  (* src = "uart.py:75" *)
  wire uart_tx_ready;
  assign \$1  = uart_rx_ready & (* src = "uart.py:317" *) empty;
  assign \$3  = ~ (* src = "uart.py:318" *) empty;
  assign \$5  = uart_tx_ack & (* src = "uart.py:318" *) \$3 ;
  always @(posedge clk)
      empty <= \$next\empty ;
  always @(posedge clk)
      data <= \$next\data ;
  uart uart (
    .clk(clk),
    .rst(rst),
    .rx(rx),
    .rx_ack(uart_rx_ack),
    .rx_data(uart_rx_data),
    .rx_ready(uart_rx_ready),
    .tx(tx),
    .tx_ack(uart_tx_ack),
    .tx_data(uart_tx_data),
    .tx_ready(uart_tx_ready)
  );
  always @* begin
    \$next\rx_strobe  = 1'h0;
    \$next\rx_strobe  = \$1 ;
  end
  always @* begin
    \$next\tx_strobe  = 1'h0;
    \$next\tx_strobe  = \$5 ;
  end
  always @* begin
    \$next\uart_rx_ack  = 1'h0;
    \$next\uart_rx_ack  = rx_strobe;
  end
  always @* begin
    \$next\uart_tx_data  = 8'h00;
    \$next\uart_tx_data  = data;
  end
  always @* begin
    \$next\uart_tx_ready  = 1'h0;
    \$next\uart_tx_ready  = tx_strobe;
  end
  always @* begin
    \$next\data  = data;
    casez (rx_strobe)
      1'h1:
          \$next\data  = uart_rx_data;
    endcase
    casez (rst)
      1'h1:
          \$next\data  = 8'h00;
    endcase
  end
  always @* begin
    \$next\empty  = empty;
    casez (rx_strobe)
      1'h1:
          \$next\empty  = 1'h0;
    endcase
    casez (tx_strobe)
      1'h1:
          \$next\empty  = 1'h1;
    endcase
    casez (rst)
      1'h1:
          \$next\empty  = 1'h1;
    endcase
  end
  assign uart_tx_ready = \$next\uart_tx_ready ;
  assign uart_tx_data = \$next\uart_tx_data ;
  assign uart_rx_ack = \$next\uart_rx_ack ;
  assign tx_strobe = \$next\tx_strobe ;
  assign rx_strobe = \$next\rx_strobe ;
endmodule

(* \nmigen.hierarchy  = "loopback.uart.rx" *)
(* generator = "nMigen" *)
module rx(rx_ack, rx_data, rst, clk, rx, rx_ready);
  wire \$1 ;
  wire \$10 ;
  wire \$12 ;
  wire \$14 ;
  wire \$16 ;
  wire [3:0] \$18 ;
  wire [3:0] \$19 ;
  wire \$3 ;
  wire [11:0] \$5 ;
  wire [11:0] \$6 ;
  wire \$8 ;
  (* src = "/usr/local/lib/python3.6/dist-packages/nmigen-0.1-py3.6.egg/nmigen/hdl/dsl.py:244" *)
  reg [2:0] \$next\fsm_state ;
  (* src = "uart.py:37" *)
  reg [2:0] \$next\rx_bitno ;
  (* src = "uart.py:28" *)
  reg [10:0] \$next\rx_counter ;
  (* src = "uart.py:19" *)
  reg [7:0] \$next\rx_data ;
  (* src = "uart.py:22" *)
  reg \$next\rx_error ;
  (* src = "uart.py:20" *)
  reg \$next\rx_ready ;
  (* src = "uart.py:29" *)
  reg \$next\rx_strobe ;
  (* src = "/usr/local/lib/python3.6/dist-packages/nmigen-0.1-py3.6.egg/nmigen/hdl/ir.py:330" *)
  input clk;
  (* init = 3'h0 *)
  (* src = "/usr/local/lib/python3.6/dist-packages/nmigen-0.1-py3.6.egg/nmigen/hdl/dsl.py:244" *)
  reg [2:0] fsm_state = 3'h0;
  (* src = "/usr/local/lib/python3.6/dist-packages/nmigen-0.1-py3.6.egg/nmigen/hdl/ir.py:330" *)
  input rst;
  (* src = "uart.py:369" *)
  input rx;
  (* src = "uart.py:21" *)
  input rx_ack;
  (* init = 3'h0 *)
  (* src = "uart.py:37" *)
  reg [2:0] rx_bitno = 3'h0;
  (* init = 11'h000 *)
  (* src = "uart.py:28" *)
  reg [10:0] rx_counter = 11'h000;
  (* init = 8'h00 *)
  (* src = "uart.py:19" *)
  output [7:0] rx_data;
  reg [7:0] rx_data = 8'h00;
  (* init = 1'h0 *)
  (* src = "uart.py:22" *)
  reg rx_error = 1'h0;
  (* init = 1'h0 *)
  (* src = "uart.py:20" *)
  output rx_ready;
  reg rx_ready = 1'h0;
  (* src = "uart.py:29" *)
  wire rx_strobe;
  assign \$10  = ~ (* src = "uart.py:41" *) rx;
  assign \$12  = rx_bitno == (* src = "uart.py:51" *) 3'h7;
  assign \$14  = ~ (* src = "uart.py:55" *) rx;
  assign \$16  = ~ (* src = "uart.py:63" *) rx;
  assign \$1  = rx_counter == (* src = "uart.py:30" *) 1'h0;
  assign \$19  = rx_bitno + (* src = "uart.py:50" *) 1'h1;
  assign \$3  = rx_counter == (* src = "uart.py:32" *) 1'h0;
  assign \$6  = rx_counter - (* src = "uart.py:35" *) 1'h1;
  assign \$8  = ~ (* src = "uart.py:41" *) rx;
  always @(posedge clk)
      rx_error <= \$next\rx_error ;
  always @(posedge clk)
      rx_ready <= \$next\rx_ready ;
  always @(posedge clk)
      rx_bitno <= \$next\rx_bitno ;
  always @(posedge clk)
      rx_data <= \$next\rx_data ;
  always @(posedge clk)
      fsm_state <= \$next\fsm_state ;
  always @(posedge clk)
      rx_counter <= \$next\rx_counter ;
  always @* begin
    \$next\rx_strobe  = 1'h0;
    \$next\rx_strobe  = \$1 ;
  end
  always @* begin
    \$next\rx_counter  = rx_counter;
    casez (\$3 )
      1'h1:
          \$next\rx_counter  = 11'h681;
      1'hz:
          \$next\rx_counter  = \$5 [10:0];
    endcase
    casez (fsm_state)
      3'h0:
          casez (\$8 )
            1'h1:
                \$next\rx_counter  = 11'h341;
          endcase
    endcase
    casez (rst)
      1'h1:
          \$next\rx_counter  = 11'h000;
    endcase
  end
  always @* begin
    \$next\fsm_state  = fsm_state;
    casez (fsm_state)
      3'h0:
          casez (\$10 )
            1'h1:
                \$next\fsm_state  = 3'h1;
          endcase
      3'h1:
          casez (rx_strobe)
            1'h1:
                \$next\fsm_state  = 3'h2;
          endcase
      3'h2:
          casez (rx_strobe)
            1'h1:
                casez (\$12 )
                  1'h1:
                      \$next\fsm_state  = 3'h3;
                endcase
          endcase
      3'h3:
          casez (rx_strobe)
            1'h1:
                casez (\$14 )
                  1'h1:
                      \$next\fsm_state  = 3'h4;
                  1'hz:
                      \$next\fsm_state  = 3'h5;
                endcase
          endcase
      3'h5:
        begin
          casez (rx_ack)
            1'h1:
                \$next\fsm_state  = 3'h0;
          endcase
          casez (\$16 )
            1'h1:
                \$next\fsm_state  = 3'h4;
          endcase
        end
    endcase
    casez (rst)
      1'h1:
          \$next\fsm_state  = 3'h0;
    endcase
  end
  always @* begin
    \$next\rx_data  = rx_data;
    casez (fsm_state)
      3'h2:
          casez (rx_strobe)
            1'h1:
                \$next\rx_data  = { rx, rx_data[7:1] };
          endcase
    endcase
    casez (rst)
      1'h1:
          \$next\rx_data  = 8'h00;
    endcase
  end
  always @* begin
    \$next\rx_bitno  = rx_bitno;
    casez (fsm_state)
      3'h2:
          casez (rx_strobe)
            1'h1:
                \$next\rx_bitno  = \$18 [2:0];
          endcase
    endcase
    casez (rst)
      1'h1:
          \$next\rx_bitno  = 3'h0;
    endcase
  end
  always @* begin
    \$next\rx_ready  = rx_ready;
    casez (fsm_state)
      3'h5:
          \$next\rx_ready  = 1'h1;
    endcase
    casez (rst)
      1'h1:
          \$next\rx_ready  = 1'h0;
    endcase
  end
  always @* begin
    \$next\rx_error  = rx_error;
    casez (fsm_state)
      3'h4:
          \$next\rx_error  = 1'h1;
    endcase
    casez (rst)
      1'h1:
          \$next\rx_error  = 1'h0;
    endcase
  end
  assign \$5  = \$6 ;
  assign \$18  = \$19 ;
  assign rx_strobe = \$next\rx_strobe ;
endmodule

(* \nmigen.hierarchy  = "loopback.uart.tx" *)
(* generator = "nMigen" *)
module tx(tx_data, tx_ready, rst, clk, tx, tx_ack);
  wire \$1 ;
  wire [3:0] \$10 ;
  wire [3:0] \$11 ;
  wire \$3 ;
  wire [11:0] \$5 ;
  wire [11:0] \$6 ;
  wire \$8 ;
  (* src = "/usr/local/lib/python3.6/dist-packages/nmigen-0.1-py3.6.egg/nmigen/hdl/dsl.py:244" *)
  reg [1:0] \$next\fsm_state ;
  (* src = "uart.py:368" *)
  reg \$next\tx ;
  (* src = "uart.py:76" *)
  reg \$next\tx_ack ;
  (* src = "uart.py:91" *)
  reg [2:0] \$next\tx_bitno ;
  (* src = "uart.py:82" *)
  reg [10:0] \$next\tx_counter ;
  (* src = "uart.py:92" *)
  reg [7:0] \$next\tx_latch ;
  (* src = "uart.py:83" *)
  reg \$next\tx_strobe ;
  (* src = "/usr/local/lib/python3.6/dist-packages/nmigen-0.1-py3.6.egg/nmigen/hdl/ir.py:330" *)
  input clk;
  (* init = 2'h0 *)
  (* src = "/usr/local/lib/python3.6/dist-packages/nmigen-0.1-py3.6.egg/nmigen/hdl/dsl.py:244" *)
  reg [1:0] fsm_state = 2'h0;
  (* src = "/usr/local/lib/python3.6/dist-packages/nmigen-0.1-py3.6.egg/nmigen/hdl/ir.py:330" *)
  input rst;
  (* init = 1'h0 *)
  (* src = "uart.py:368" *)
  output tx;
  reg tx = 1'h0;
  (* init = 1'h0 *)
  (* src = "uart.py:76" *)
  output tx_ack;
  reg tx_ack = 1'h0;
  (* init = 3'h0 *)
  (* src = "uart.py:91" *)
  reg [2:0] tx_bitno = 3'h0;
  (* init = 11'h000 *)
  (* src = "uart.py:82" *)
  reg [10:0] tx_counter = 11'h000;
  (* src = "uart.py:74" *)
  input [7:0] tx_data;
  (* init = 8'h00 *)
  (* src = "uart.py:92" *)
  reg [7:0] tx_latch = 8'h00;
  (* src = "uart.py:75" *)
  input tx_ready;
  (* src = "uart.py:83" *)
  wire tx_strobe;
  assign \$11  = tx_bitno + (* src = "uart.py:123" *) 1'h1;
  assign \$1  = tx_counter == (* src = "uart.py:84" *) 1'h0;
  assign \$3  = tx_counter == (* src = "uart.py:86" *) 1'h0;
  assign \$6  = tx_counter - (* src = "uart.py:89" *) 1'h1;
  assign \$8  = tx_bitno == (* src = "uart.py:124" *) 3'h7;
  always @(posedge clk)
      fsm_state <= \$next\fsm_state ;
  always @(posedge clk)
      tx <= \$next\tx ;
  always @(posedge clk)
      tx_latch <= \$next\tx_latch ;
  always @(posedge clk)
      tx_ack <= \$next\tx_ack ;
  always @(posedge clk)
      tx_counter <= \$next\tx_counter ;
  always @(posedge clk)
      tx_bitno <= \$next\tx_bitno ;
  always @* begin
    \$next\tx_strobe  = 1'h0;
    \$next\tx_strobe  = \$1 ;
  end
  always @* begin
    \$next\tx_counter  = tx_counter;
    casez (\$3 )
      1'h1:
          \$next\tx_counter  = 11'h681;
      1'hz:
          \$next\tx_counter  = \$5 [10:0];
    endcase
    casez (fsm_state)
      2'h0:
          casez (tx_ready)
            1'h1:
                \$next\tx_counter  = 11'h681;
          endcase
    endcase
    casez (rst)
      1'h1:
          \$next\tx_counter  = 11'h000;
    endcase
  end
  always @* begin
    \$next\tx_ack  = tx_ack;
    casez (fsm_state)
      2'h0:
          \$next\tx_ack  = 1'h1;
    endcase
    casez (rst)
      1'h1:
          \$next\tx_ack  = 1'h0;
    endcase
  end
  always @* begin
    \$next\tx_latch  = tx_latch;
    casez (fsm_state)
      2'h0:
          casez (tx_ready)
            1'h1:
                \$next\tx_latch  = tx_data;
          endcase
      2'h2:
          casez (tx_strobe)
            1'h1:
                \$next\tx_latch  = { 1'h0, tx_latch[7:1] };
          endcase
    endcase
    casez (rst)
      1'h1:
          \$next\tx_latch  = 8'h00;
    endcase
  end
  always @* begin
    \$next\tx  = tx;
    casez (fsm_state)
      2'h1:
          casez (tx_strobe)
            1'h1:
                \$next\tx  = 1'h0;
          endcase
      2'h2:
          casez (tx_strobe)
            1'h1:
                \$next\tx  = tx_latch[0];
          endcase
      2'h3:
          casez (tx_strobe)
            1'h1:
                \$next\tx  = 1'h1;
          endcase
    endcase
    casez (rst)
      1'h1:
          \$next\tx  = 1'h0;
    endcase
  end
  always @* begin
    \$next\fsm_state  = fsm_state;
    casez (fsm_state)
      2'h1:
          casez (tx_strobe)
            1'h1:
                \$next\fsm_state  = 2'h2;
          endcase
      2'h2:
          casez (tx_strobe)
            1'h1:
                casez (\$8 )
                  1'h1:
                      \$next\fsm_state  = 2'h3;
                endcase
          endcase
      2'h3:
          casez (tx_strobe)
            1'h1:
                \$next\fsm_state  = 2'h0;
          endcase
    endcase
    casez (rst)
      1'h1:
          \$next\fsm_state  = 2'h0;
    endcase
  end
  always @* begin
    \$next\tx_bitno  = tx_bitno;
    casez (fsm_state)
      2'h2:
          casez (tx_strobe)
            1'h1:
                \$next\tx_bitno  = \$10 [2:0];
          endcase
    endcase
    casez (rst)
      1'h1:
          \$next\tx_bitno  = 3'h0;
    endcase
  end
  assign \$5  = \$6 ;
  assign \$10  = \$11 ;
  assign tx_strobe = \$next\tx_strobe ;
endmodule

(* \nmigen.hierarchy  = "loopback.uart" *)
(* generator = "nMigen" *)
module uart(tx_ack, rx_ack, tx_data, tx_ready, rx_data, rst, clk, tx, rx, rx_ready);
  (* src = "/usr/local/lib/python3.6/dist-packages/nmigen-0.1-py3.6.egg/nmigen/hdl/ir.py:330" *)
  input clk;
  (* src = "/usr/local/lib/python3.6/dist-packages/nmigen-0.1-py3.6.egg/nmigen/hdl/ir.py:330" *)
  input rst;
  (* src = "uart.py:369" *)
  input rx;
  (* src = "uart.py:21" *)
  input rx_ack;
  (* src = "uart.py:19" *)
  output [7:0] rx_data;
  (* src = "uart.py:20" *)
  output rx_ready;
  (* src = "uart.py:368" *)
  output tx;
  (* src = "uart.py:76" *)
  output tx_ack;
  (* src = "uart.py:74" *)
  input [7:0] tx_data;
  (* src = "uart.py:75" *)
  input tx_ready;
  rx \rx$2  (
    .clk(clk),
    .rst(rst),
    .rx(rx),
    .rx_ack(rx_ack),
    .rx_data(rx_data),
    .rx_ready(rx_ready)
  );
  tx \tx$1  (
    .clk(clk),
    .rst(rst),
    .tx(tx),
    .tx_ack(tx_ack),
    .tx_data(tx_data),
    .tx_ready(tx_ready)
  );
endmodule

